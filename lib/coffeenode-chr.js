// Generated by CoffeeScript 1.6.3
(function() {
  var TYPES, binary_interval_search, character_sets_and_ranges, dec, decG, hex, hexG, name, nameO, nameOG;

  TYPES = require('coffeenode-types');

  character_sets_and_ranges = require('character-sets-and-ranges');

  this._names_and_ranges_by_csg = character_sets_and_ranges['names-and-ranges-by-csg'];

  binary_interval_search = require('binary-interval-search');

  this.chrs_from_text = function(text, options) {
    var input_mode, splitter, _ref;
    if (text.length === 0) {
      return [];
    }
    switch (input_mode = (_ref = options != null ? options['input'] : void 0) != null ? _ref : 'plain') {
      case 'plain':
        splitter = this._plain_splitter;
        break;
      case 'ncr':
        splitter = this._ncr_splitter;
        break;
      case 'xncr':
        splitter = this._xncr_splitter;
        break;
      default:
        throw new Error("unknown input mode: " + (rpr(input_mode)));
    }
    return (text.split(splitter)).filter(function(element, idx) {
      return element.length !== 0;
    });
  };

  this._new_chunk = function(csg, rsg, chrs) {
    var R;
    R = {
      '~isa': 'CHR/chunk',
      'csg': csg,
      'rsg': rsg,
      'text': chrs.join('')
    };
    return R;
  };

  this.chunks_from_text = function(text, options) {

    /* Given a `text` and `options` (of which `csg` is irrelevant here), return a list of `CHR/chunk`
    objects (as returned by `CHR._new_chunk`) that describes stretches of characters with codepoints in the
    same 'range' (Unicode block).
     */
    var R, chr, chrs, csg, description, last_csg, last_rsg, output_mode, rsg, transform_output, _i, _len, _ref, _ref1;
    R = [];
    if (text.length === 0) {
      return R;
    }
    last_csg = 'u';
    last_rsg = null;
    chrs = [];
    switch (output_mode = (_ref = options != null ? options['output'] : void 0) != null ? _ref : 'plain') {
      case 'plain':
        transform_output = function(chr) {
          return chr;
        };
        break;
      case 'html':
        transform_output = function(chr) {
          switch (chr) {
            case '&':
              return '&amp;';
            case '<':
              return '&lt;';
            case '>':
              return '&gt;';
            default:
              return chr;
          }
        };
        break;
      default:
        throw new Error("unknown output mode: " + (rpr(output_mode)));
    }
    _ref1 = this.chrs_from_text(text, options);
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      chr = _ref1[_i];
      description = this.analyze(chr, options);
      csg = description.csg, rsg = description.rsg;
      chr = description[csg === 'u' ? 'chr' : 'ncr'];
      if (rsg !== last_rsg) {
        if (chrs.length > 0) {
          R.push(this._new_chunk(last_csg, last_rsg, chrs));
        }
        last_csg = csg;
        last_rsg = rsg;
        chrs = [];
      }
      chrs.push(transform_output(chr));
    }
    if (chrs.length > 0) {
      R.push(this._new_chunk(last_csg, last_rsg, chrs));
    }
    return R;
  };

  this.html_from_text = function(text, options) {
    var R, chunk, chunks, input_mode, _i, _len, _ref;
    R = [];
    input_mode = (_ref = options != null ? options['input'] : void 0) != null ? _ref : 'plain';
    chunks = this.chunks_from_text(text, {
      input: input_mode,
      output: 'html'
    });
    for (_i = 0, _len = chunks.length; _i < _len; _i++) {
      chunk = chunks[_i];
      R.push("<span class=\"" + chunk['rsg'] + "\">" + chunk['text'] + "</span>");
    }
    return R.join('');
  };

  this.cid_from_chr = function(chr, options) {
    var input_mode, _ref;
    input_mode = (_ref = options != null ? options['input'] : void 0) != null ? _ref : 'plain';
    return (this._chr_csg_cid_from_chr(chr, input_mode))[2];
  };

  this.csg_cid_from_chr = function(chr, options) {
    var input_mode, _ref;
    input_mode = (_ref = options != null ? options['input'] : void 0) != null ? _ref : 'plain';
    return (this._chr_csg_cid_from_chr(chr, input_mode)).slice(1);
  };

  this._chr_csg_cid_from_chr = function(chr, input_mode) {

    /* Given a text with one or more characters, return the first character, its CSG, and its CID (as a
    non-negative integer). Additionally, an input mode may be given as either `plain`, `ncr`, or `xncr`.
     */
    var cid, cid_dec, cid_hex, csg, first_chr, hi, lo, match, matcher;
    if (chr.length === 0) {
      throw new Error("unable to obtain CID from empty string");
    }
    if (input_mode == null) {
      input_mode = 'plain';
    }
    switch (input_mode) {
      case 'plain':
        matcher = this._first_chr_matcher_plain;
        break;
      case 'ncr':
        matcher = this._first_chr_matcher_ncr;
        break;
      case 'xncr':
        matcher = this._first_chr_matcher_xncr;
        break;
      default:
        throw new Error("unknown input mode: " + (rpr(input_mode)));
    }
    match = chr.match(matcher);
    if (match == null) {
      throw new Error("illegal character sequence in " + (rpr(chr)));
    }
    first_chr = match[0];
    switch (first_chr.length) {
      case 1:
        return [first_chr, 'u', first_chr.charCodeAt(0)];
      case 2:

        /* thx to http://perldoc.perl.org/Encode/Unicode.html */
        hi = first_chr.charCodeAt(0);
        lo = first_chr.charCodeAt(1);
        cid = (hi - 0xD800) * 0x400 + (lo - 0xDC00) + 0x10000;
        return [first_chr, 'u', cid];
      default:
        chr = match[0], csg = match[1], cid_hex = match[2], cid_dec = match[3];
        cid = cid_hex != null ? parseInt(cid_hex, 16) : parseInt(cid_dec, 10);
        if (csg.length === 0) {
          csg = 'u';
        }
        return [first_chr, csg, cid];
    }
  };

  this.as_csg = function(cid_hint, O) {
    return (this._csg_cid_from_hint(cid_hint, O))[0];
  };

  this.as_cid = function(cid_hint, O) {
    return (this._csg_cid_from_hint(cid_hint, O))[1];
  };

  this.as_chr = function(cid_hint, O) {
    return this._as_chr.apply(this, this._csg_cid_from_hint(cid_hint, O));
  };

  this.as_fncr = function(cid_hint, O) {
    return this._as_fncr.apply(this, this._csg_cid_from_hint(cid_hint, O));
  };

  this.as_sfncr = function(cid_hint, O) {
    return this._as_sfncr.apply(this, this._csg_cid_from_hint(cid_hint, O));
  };

  this.as_xncr = function(cid_hint, O) {
    return this._as_xncr.apply(this, this._csg_cid_from_hint(cid_hint, O));
  };

  this.as_ncr = function(cid_hint, O) {
    return this._as_xncr.apply(this, this._csg_cid_from_hint(cid_hint, O));
  };

  this.as_rsg = function(cid_hint, O) {
    return this._as_rsg.apply(this, this._csg_cid_from_hint(cid_hint, O));
  };

  this.as_range_name = function(cid_hint, O) {
    return this._as_range_name.apply(this, this._csg_cid_from_hint(cid_hint, O));
  };

  this.analyze = function(cid_hint, O) {
    return this._analyze.apply(this, this._csg_cid_from_hint(cid_hint, O));
  };

  this._analyze = function(csg, cid) {
    var R, chr, ncr, xncr;
    if (csg === 'u') {
      chr = this._unicode_chr_from_cid(cid);
      ncr = xncr = this._as_xncr(csg, cid);
    } else {
      chr = this._as_xncr(csg, cid);
      xncr = this._as_xncr(csg, cid);
      ncr = this._as_xncr('u', cid);
    }
    R = {
      '~isa': 'CHR/info',
      'chr': chr,
      'csg': csg,
      'cid': cid,
      'fncr': this._as_fncr(csg, cid),
      'sfncr': this._as_sfncr(csg, cid),
      'ncr': ncr,
      'xncr': xncr,
      'rsg': this._as_rsg(csg, cid)
    };
    return R;
  };

  this._as_chr = function(csg, cid) {
    if (csg === 'u') {
      return this._unicode_chr_from_cid(cid);
    }
    return retrun((this._analyze(csg, cid))['chr']);
  };

  this._unicode_chr_from_cid = function(cid) {
    var hi, lo;
    if (cid <= 0xffff) {
      return String.fromCharCode(cid);
    }

    /* thx to http://perldoc.perl.org/Encode/Unicode.html */
    hi = (Math.floor((cid - 0x10000) / 0x400)) + 0xD800;
    lo = (cid - 0x10000) % 0x400 + 0xDC00;
    return (String.fromCharCode(hi)) + (String.fromCharCode(lo));
  };

  this._as_fncr = function(csg, cid) {
    var rsg, _ref;
    rsg = (_ref = this._as_rsg(csg, cid)) != null ? _ref : csg;
    return "" + rsg + "-" + (cid.toString(16));
  };

  this._as_sfncr = function(csg, cid) {
    return "" + csg + "-" + (cid.toString(16));
  };

  this._as_xncr = function(csg, cid) {
    if (csg === 'u' || (csg == null)) {
      csg = '';
    }
    return "&" + csg + "#x" + (cid.toString(16)) + ";";
  };

  this._as_rsg = function(csg, cid) {
    return binary_interval_search(this._names_and_ranges_by_csg[csg], 'first-cid', 'last-cid', 'rsg', cid);
  };

  this._as_range_name = function(csg, cid) {
    return binary_interval_search(this._names_and_ranges_by_csg[csg], 'first-cid', 'last-cid', 'range-name', cid);
  };

  this._csg_cid_from_hint = function(cid_hint, options) {

    /* This helper is used to derive the correct CSG and CID from arguments as accepted by the `as_*` family
    of methods, such as `CHR.as_fncr`, `CHR.as_rsg` and so on; its output may be directly applied to the
    respective namesake private method (`CHR._as_fncr`, `CHR._as_rsg` and so on). The method arguments should
    obey the following rules:
    
    * Methods may be called with one or two arguments; the first is known as the 'CID hint', the second as
      'options'.
    
    * The CID hint may be a number or a text; if it is a number, it is understood as a CID; if it
      is a text, its interpretation is subject to the `options[ 'input' ]` setting.
    
    * Options must be a POD with the optional members `input` and `csg`.
    
    * `options[ 'input' ]` is *only* observed if the CID hint is a text; it governs which kinds of character
      references are recognized in the text. `input` may be one of `plain`, `ncr`, or `xncr`; it defaults to
      `plain` (no character references will be recognized).
    
    * `options[ 'csg' ]` sets the character set sigil. If `csg` is set in the options, then it will override
      whatever the outcome of `CHR.csg_cid_from_chr` w.r.t. CSG is—in other words, if you call
      `CHR.as_sfncr '&jzr#xe100', input: 'xncr', csg: 'u'`, you will get `u-e100`, with the numerically
      equivalent codepoint from the `u` (Unicode) character set.
    
    * Before CSG and CID are returned, they will be validated for plausibility.
     */
    var cid, csg, csg_of_cid_hint, csg_of_options, input_mode, type, _ref;
    switch (type = TYPES.type_of(options)) {
      case 'null':
      case 'jsundefined':
        csg_of_options = null;
        input_mode = null;
        break;
      case 'pod':
        csg_of_options = options['csg'];
        input_mode = options['input'];
        break;
      default:
        throw new Error("expected a POD as second argument, got a " + type);
    }
    switch (type = TYPES.type_of(cid_hint)) {
      case 'number':
        csg_of_cid_hint = null;
        cid = cid_hint;
        break;
      case 'text':
        _ref = this.csg_cid_from_chr(cid_hint, {
          input: input_mode
        }), csg_of_cid_hint = _ref[0], cid = _ref[1];
        break;
      default:
        throw new Error("expected a text or a number as first argument, got a " + type);
    }
    if (csg_of_options != null) {
      csg = csg_of_options;
    } else if (csg_of_cid_hint != null) {
      csg = csg_of_cid_hint;
    } else {
      csg = 'u';
    }
    this.validate_is_csg(csg);
    this.validate_is_cid(cid);
    return [csg, cid];
  };

  name = /(?:[a-z][a-z0-9]*)/.source;

  nameO = /(?:(?:[a-z][a-z0-9]*)|)/.source;

  nameOG = /((?:[a-z][a-z0-9]*)|)/.source;

  hex = /(?:x[a-fA-F0-9]+)/.source;

  hexG = /(?:x([a-fA-F0-9]+))/.source;

  dec = /(?:[0-9]+)/.source;

  decG = /(?:([0-9]+))/.source;

  this._csg_matcher = RegExp("^" + name + "$");

  this._ncr_matcher = RegExp("(?:&\\#(?:" + hex + "|" + dec + ");)");

  this._xncr_matcher = RegExp("(?:&" + nameO + "\\#(?:" + hex + "|" + dec + ");)");

  this._ncr_csg_cid_matcher = RegExp("(?:&()\\#(?:" + hexG + "|" + decG + ");)");

  this._xncr_csg_cid_matcher = RegExp("(?:&" + nameOG + "\\#(?:" + hexG + "|" + decG + ");)");


  /* Matchers for surrogate sequences and non-surrogate, 'ordinary' characters: */

  this._surrogate_matcher = /(?:[\ud800-\udbff][\udc00-\udfff])/;

  this._nonsurrogate_matcher = /[^\ud800-\udbff\udc00-\udfff]/;


  /* Matchers for the first character of a string, in three modes (`plain`, `ncr`, `xncr`): */

  this._first_chr_matcher_plain = RegExp("^(?:" + this._surrogate_matcher.source + "|" + this._nonsurrogate_matcher.source + ")");

  this._first_chr_matcher_ncr = RegExp("^(?:" + this._surrogate_matcher.source + "|" + this._ncr_csg_cid_matcher.source + "|" + this._nonsurrogate_matcher.source + ")");

  this._first_chr_matcher_xncr = RegExp("^(?:" + this._surrogate_matcher.source + "|" + this._xncr_csg_cid_matcher.source + "|" + this._nonsurrogate_matcher.source + ")");

  this._plain_splitter = RegExp("(" + this._surrogate_matcher.source + "|" + this._nonsurrogate_matcher.source + ")");

  this._ncr_splitter = RegExp("(" + this._ncr_matcher.source + "|" + this._surrogate_matcher.source + "|" + this._nonsurrogate_matcher.source + ")");

  this._xncr_splitter = RegExp("(" + this._xncr_matcher.source + "|" + this._surrogate_matcher.source + "|" + this._nonsurrogate_matcher.source + ")");

  this.validate_is_csg = function(x) {
    TYPES.validate_isa_text(x);
    if ((x.match(this._csg_matcher)) == null) {
      throw new Error("not a valid CSG: " + (rpr(x)));
    }
    if (this._names_and_ranges_by_csg[x] == null) {
      throw new Error("unknown CSG: " + (rpr(x)));
    }
    return null;
  };

  this.validate_is_cid = function(x) {
    TYPES.validate_isa_number(x);
    if (x < 0 || x > 0xffffffff || (parseInt(x)) !== x) {
      throw new Error("expected an integer between 0x0 and 0x10ffff, got 0x" + (x.toString(16)));
    }
    return null;
  };

}).call(this);
