// Generated by CoffeeScript 1.6.3
(function() {
  var js_type_of,
    __slice = [].slice;

  js_type_of = function(x) {
    return Object.prototype.toString.call(x);
  };


  /* There appear to have been some changes in NodeJS concerning where to find `isXY` methods: */

  this._coffeenode_type_by_js_type = {
    '[object Array]': 'list',
    '[object Boolean]': 'boolean',
    '[object Function]': 'function',
    '[object Null]': 'null',
    '[object String]': 'text',
    '[object Generator]': 'generator',
    '[object Undefined]': 'jsundefined',
    '[object Arguments]': 'jsarguments',
    '[object Date]': 'jsdate',
    '[object Error]': 'jserror',
    '[object global]': 'jsglobal',
    '[object RegExp]': 'jsregex',
    '[object DOMWindow]': 'jswindow',
    '[object CanvasRenderingContext2D]': 'jsctx',
    '[object ArrayBuffer]': 'jsarraybuffer',
    '[object Object]': function(x) {
      return 'pod';
    },
    '[object Number]': function(x) {
      if (isNaN(x)) {
        return 'jsnotanumber';
      }
      if (x === Infinity || x === -Infinity) {
        return 'jsinfinity';
      }
      return 'number';
    }
  };

  this.type_of = function(x) {
    "Given any kind of value ``x``, return its type.";
    var R, js_type;
    if (x === null) {
      return 'null';
    }
    if (x === void 0) {
      return 'jsundefined';
    }
    R = x['~isa'];
    if (R != null) {
      return R;
    }
    js_type = js_type_of(x);
    R = this._coffeenode_type_by_js_type[js_type];
    if (R == null) {
      return js_type.replace(/^\[object (.+)\]$/, '$1');
    }
    if (this.isa_function(R)) {
      return R(x);
    } else {
      return R;
    }
  };

  this.isa = function(x, probe) {
    "Given any value ``x`` and a non-empty text ``probe``, return whether ``TYPES/type_of x`` equals\n``probe``.";
    return (this.type_of(x)) === probe;
  };

  this.isa_list = function(x) {
    return (js_type_of(x)) === '[object Array]';
  };

  this.isa_boolean = function(x) {
    return (js_type_of(x)) === '[object Boolean]';
  };

  this.isa_function = function(x) {
    return (js_type_of(x)) === '[object Function]';
  };

  this.isa_pod = function(x) {
    return (js_type_of(x)) === '[object Object]';
  };

  this.isa_text = function(x) {
    return (js_type_of(x)) === '[object String]';
  };

  this.isa_number = function(x) {
    return (js_type_of(x)) === '[object Number]' && isFinite(x);
  };

  this.isa_null = function(x) {
    return x === null;
  };

  this.isa_jsundefined = function(x) {
    return x === void 0;
  };

  this.isa_infinity = function(x) {
    return x === Infinity || x === -Infinity;
  };

  this.isa_jsarguments = function(x) {
    return (js_type_of(x)) === '[object Arguments]';
  };

  this.isa_jsnotanumber = function(x) {
    return isNaN(x);
  };

  this.isa_jsdate = function(x) {
    return (js_type_of(x)) === '[object Date]';
  };

  this.isa_jsglobal = function(x) {
    return (js_type_of(x)) === '[object global]';
  };

  this.isa_jsregex = function(x) {
    return (js_type_of(x)) === '[object RegExp]';
  };

  this.isa_jserror = function(x) {
    return (js_type_of(x)) === '[object Error]';
  };

  this.isa_jswindow = function(x) {
    return (js_type_of(x)) === '[object DOMWindow]';
  };

  this.isa_jsctx = function(x) {
    return (js_type_of(x)) === '[object CanvasRenderingContext2D]';
  };

  this.isa_jsarraybuffer = function(x) {
    return (js_type_of(x)) === '[object ArrayBuffer]';
  };

  this.simple_equality_types = {
    'number': true,
    'infinity': true,
    'text': true,
    'boolean': true,
    'null': true,
    'jsundefined': true
  };

  this.simple_comparison_types = {
    'number': true,
    'infinity': true,
    'text': true,
    'boolean': true,
    'null': true
  };

  this.validate_isa = function() {
    var message, probe_type, type, types, x, _i, _len;
    x = arguments[0], types = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (types.length === 0) {
      throw new Error("expected one or more types, got none");
    }
    probe_type = this.type_of(x);
    for (_i = 0, _len = types.length; _i < _len; _i++) {
      type = types[_i];
      if (type === probe_type) {
        return null;
      }
    }
    if (types.length === 1) {
      message = "expected a " + types[0] + ", got a " + probe_type;
    } else {
      types = types.join(', ');
      message = "expected value to have one of these types: " + types + ", got a " + probe_type;
    }
    return null;
  };

  (function(_this) {
    return (function() {
      var match, name, type, _results;
      _results = [];
      for (name in _this) {
        match = name.match(/^isa_(.+)/);
        if (match == null) {
          continue;
        }
        type = match[1];
        _results.push((function(name, type) {
          return _this["validate_" + name] = function(x) {
            if (this[name](x)) {
              return null;
            }
            throw new Error("expected a " + type + ", got a " + (this.type_of(x)));
          };
        })(name, type));
      }
      return _results;
    });
  })(this)();

}).call(this);
