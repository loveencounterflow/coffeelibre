// Generated by CoffeeScript 1.6.3
(function() {
  var TRM, TYPES, log, rpr,
    __slice = [].slice;

  TYPES = require('coffeenode-types');

  TRM = require('coffeelibre-trm');

  rpr = TRM.rpr.bind(TRM);

  log = TRM.log.bind(TRM);

  this.repeat = function(me, count) {
    return (new Array(count + 1)).join(me);
  };

  this.push = function(me, you) {
    return me + you;
  };

  this.copy = function(me) {
    return me;
  };

  this.starts_with = function(me, probe, idx) {
    if (idx == null) {
      idx = 0;
    }
    return (me.lastIndexOf(probe, idx)) === idx;
  };

  this.ends_with = function(me, search_text) {
    var delta;
    delta = me.length - search_text.length;
    return delta >= 0 && (me.lastIndexOf(search_text)) === delta;
  };

  this.drop_prefix = function(me, probe) {
    if (this.starts_with(me, probe)) {
      return me.substr(probe.length);
    }
    return me;
  };

  this.drop_suffix = function(me, probe) {
    if (this.ends_with(me, probe)) {
      return me.substr(0, me.length - probe.length);
    }
    return me;
  };

  this.contains = function(me, probe) {
    var type_of_probe;
    switch (type_of_probe = TYPES.type_of(probe)) {
      case 'text':
        if (probe.length === 0) {
          return true;
        }
        return (me.indexOf(probe)) >= 0;
      case 'jsregex':
        return (me.match(probe)) != null;
      default:
        throw new Error("unknown type for TEXT/contains: " + type_of_probe);
    }
  };

  this.contains_only_digits = function(me) {
    if (this.is_empty(me)) {
      return false;
    }
    return (me.match(/^[0-9]+$/)) != null;
  };

  this.is_empty = function(me) {
    return me.length === 0;
  };


  /* TAINT.TODO will only split once when given a text probe; unexpected results when starts
    or ends with probe; will fail with 32bit codepoints
   */

  this.split = function(me, probe) {
    var R;
    if (probe == null) {
      return this.words_of(me);
    }
    R = me.split(probe);
    return R.filter(function(element) {
      return element !== void 0;
    });
  };


  /* TAINT.TODO "might not recognize all Unicode whitespace codepoints"
   */

  this.words_of = function(me) {
    return (me.replace(/^\s*(.*?)\s*$/g, '$1')).split(/\s+/g);
  };

  this.as_text = function(me) {
    return me;
  };

  this.trim = function(me) {
    return this._trim_whitespace(me, true, true);
  };

  this.trim_left = function(me) {
    return this._trim_whitespace(me, true, false);
  };

  this.trim_right = function(me) {
    return this._trim_whitespace(me, false, true);
  };

  this._trim_whitespace = function(me, trim_left, trim_right) {

    /*Faster whitespace trimming; adapted from
    http://blog.stevenlevithan.com/archives/faster-trim-javascript.
     */
    var i, whitespace;
    if (trim_left) {
      me = me.replace(/^\s\s*/, '');
    }
    if (trim_right) {
      whitespace = /\s/;
      i = me.length;
      while (whitespace.test(me.charAt(--i))) {
        null;
      }
      me = me.slice(0, i + 1);
    }
    return me;
  };

  this.flush_left = function(x, width, filler) {
    if (width == null) {
      width = 25;
    }
    if (filler == null) {
      filler = ' ';
    }
    return this.flush(x, width, 'left', filler);
  };

  this.flush_right = function(x, width, filler) {
    if (width == null) {
      width = 25;
    }
    if (filler == null) {
      filler = ' ';
    }
    return this.flush(x, width, 'right', filler);
  };

  this.flush = function(x, width, align, filler) {
    var filler_length, padding, text_length;
    if (filler == null) {
      filler = ' ';
    }

    /*Given a value, a non-negative integer ``width``, and an optional, non-empty text ``filler`` (which
    defaults to a single space), return a string that starts with the text (or the text of the representation
    of the value), and is padded with as many fillers as needed to make the string ``width`` characters long.
    If ``width`` is zero or smaller than the length of the text, the text is simply returned as-is. No
    clipping of text is ever done.
     */
    if (!(align === 'left' || align === 'right')) {
      throw new Error("expected ``left`` or ``right`` for ``align``, got " + (rpr(align)));
    }
    if (!TYPES.isa_text(x)) {
      x = rpr(x);
    }
    filler_length = filler.length;
    text_length = x.length;
    if (text_length >= width) {
      return x;
    }
    padding = this.repeat(filler, width - text_length);
    if (align === 'left') {
      return x + padding;
    } else {
      return padding + x;
    }
  };

  this.lower_case = function(me) {
    return me.toLowerCase();
  };

  this.upper_case = function(me) {
    return me.toUpperCase();
  };


  /* TAINT.UNICODE will incorrectly count codepoints above u/ffff as two chrs
   */

  this.length_of = function(me) {
    return me.length;
  };

  this.lines_of = function(me, handler) {

    /*Given a text and an optional handler, either return a list of lines (without line endings) if handler
    is not given, or call handler as `handler error, line` for each line in the text, and one more call where
    `line` is `null` after the end of the text has been encountered. In either case, all lines will be
    stripped of trailine whitespace, including newline characters; recognized newlines are the usual suspects
    for Unix, Windows, and MacOS systems (namely, `\\n`, `\\r\\n`, and `\\r`).
    
    **Implementation Note**: Implementation of asynchronous version postponed.
     */
    if (handler == null) {
      return me.split(this._line_splitter);
    }
    throw new Error("asynchronous TEXT.lines_of not yet supported");
  };

  this._line_splitter = /\r\n|[\n\v\f\r\x85\u2028\u2029]/g;

  this.reverse = function(me) {
    return (this.chrs_of(me)).reverse().join('');
  };

  this.add = function() {
    var me_and_you;
    me_and_you = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return me_and_you.join('');
  };


  /* TAINT.UNICODE "will split codepoints beyond u/ffff"
   */

  this.partition = function(me, partitioner) {
    var R, idx, m, max_idx, n, remainder, _i;
    n = partitioner;
    m = me.length;
    idx = -n;
    max_idx = m - n;
    remainder = m % n;
    R = [];
    if (remainder !== 0) {
      throw new Error("expected length of text to be a multiple of " + n + ", got text with " + m + " characters");
    }
    for (idx = _i = 0; n > 0 ? _i <= max_idx : _i >= max_idx; idx = _i += n) {
      R.push(this.slice(me, idx, idx + n));
    }
    return R;
  };

  this.slice = function(me, start, stop) {
    if (start == null) {
      start = 0;
    }
    if (stop == null) {
      stop = me.length;
    }
    if (start >= stop) {
      return '';
    }
    return me.slice(start, stop);
  };

  this.shuffle = function(me) {
    return (LIST.shuffle(this.chrs_of(me))).join('');
  };

  this.validate_is_nonempty_text = function(me) {
    TYPES.validate_isa_text(me);
    if (!(me.length > 0)) {
      throw new Error("expected a non-empty text, got an empty one");
    }
  };

  this.validate_is_word = function(me) {
    this.validate_is_nonempty_text(me);
    if ((me.match(/^\S+$/)) == null) {
      throw new Error("expected a non-empty text without whitespace");
    }
  };

}).call(this);
